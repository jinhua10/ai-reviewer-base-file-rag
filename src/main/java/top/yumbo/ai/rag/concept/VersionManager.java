package top.yumbo.ai.rag.concept;

import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import top.yumbo.ai.rag.i18n.I18N;

import java.time.LocalDateTime;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

/**
 * 版本管理器 (Version Manager)
 *
 * 管理概念单元的版本历史
 * (Manages version history of concept units)
 *
 * @author AI Reviewer Team
 * @since 2.0.0
 */
@Slf4j
@Service
public class VersionManager {

    /**
     * 概念历史缓存 (Concept history cache)
     * Key: conceptId, Value: ConceptHistory
     */
    private final Map<String, ConceptHistory> historyCache = new ConcurrentHashMap<>();

    /**
     * 版本保留策略配置 (Version retention policy)
     */
    private final int maxVersionsPerConcept = 50;  // 每个概念最多保留50个版本
    private final int cleanupThreshold = 60;       // 超过60个版本时触发清理

    // ==================== 版本创建 (Version Creation) ====================

    /**
     * 创建初始版本 (Create initial version)
     *
     * @param concept 概念单元 (Concept unit)
     * @return 概念历史 (Concept history)
     */
    public ConceptHistory createInitialVersion(ConceptUnit concept) {
        log.info(I18N.get("concept.version.creating.initial", concept.getId(), concept.getName()));

        ConceptVersion initialVersion = ConceptVersion.builder()
                .versionId(generateVersionId(concept.getId(), 1))
                .conceptId(concept.getId())
                .versionNumber(1)
                .snapshot(cloneConcept(concept))
                .changeType(ConceptVersion.ChangeType.CREATE)
                .changeDescription("初始版本 (Initial version)")
                .createdAt(LocalDateTime.now())
                .createdBy("system")
                .autoGenerated(true)
                .build();

        initialVersion.markAsStable();

        ConceptHistory history = ConceptHistory.builder()
                .historyId(generateHistoryId(concept.getId()))
                .conceptId(concept.getId())
                .versions(new ArrayList<>(Collections.singletonList(initialVersion)))
                .currentVersion(1)
                .createdAt(LocalDateTime.now())
                .updatedAt(LocalDateTime.now())
                .totalChanges(1)
                .build();

        historyCache.put(concept.getId(), history);

        log.info(I18N.get("concept.version.initial.created", concept.getId(), 1));
        return history;
    }

    /**
     * 创建新版本 (Create new version)
     *
     * @param concept 更新后的概念 (Updated concept)
     * @param changeType 变更类型 (Change type)
     * @param changeDescription 变更描述 (Change description)
     * @param changeReason 变更原因 (Change reason)
     * @param createdBy 创建者 (Creator)
     * @return 新版本 (New version)
     */
    public ConceptVersion createNewVersion(ConceptUnit concept,
                                          ConceptVersion.ChangeType changeType,
                                          String changeDescription,
                                          String changeReason,
                                          String createdBy) {
        log.info(I18N.get("concept.version.creating.new", concept.getId(), changeType.getEnglishName()));

        ConceptHistory history = getOrCreateHistory(concept);

        int newVersionNumber = history.getCurrentVersion() + 1;

        ConceptVersion newVersion = ConceptVersion.builder()
                .versionId(generateVersionId(concept.getId(), newVersionNumber))
                .conceptId(concept.getId())
                .versionNumber(newVersionNumber)
                .snapshot(cloneConcept(concept))
                .changeType(changeType)
                .changeDescription(changeDescription)
                .changeReason(changeReason)
                .createdAt(LocalDateTime.now())
                .createdBy(createdBy)
                .autoGenerated(false)
                .build();

        history.addVersion(newVersion);

        // 更新概念本身的版本号 (Update concept version number)
        concept.setVersion(newVersionNumber);
        concept.setHasHistory(true);
        concept.setUpdatedAt(LocalDateTime.now());
        concept.setUpdatedBy(createdBy);

        log.info(I18N.get("concept.version.created", concept.getId(), newVersionNumber));

        // 检查是否需要清理旧版本 (Check if old versions need cleanup)
        if (history.needsCleanup(cleanupThreshold)) {
            cleanupOldVersions(concept.getId());
        }

        return newVersion;
    }

    // ==================== 版本查询 (Version Query) ====================

    /**
     * 获取概念历史 (Get concept history)
     *
     * @param conceptId 概念ID (Concept ID)
     * @return 概念历史 (Concept history)
     */
    public ConceptHistory getHistory(String conceptId) {
        ConceptHistory history = historyCache.get(conceptId);
        if (history == null) {
            log.warn(I18N.get("concept.version.history.notfound", conceptId));
        }
        return history;
    }

    /**
     * 获取或创建历史记录 (Get or create history)
     *
     * @param concept 概念单元 (Concept unit)
     * @return 概念历史 (Concept history)
     */
    public ConceptHistory getOrCreateHistory(ConceptUnit concept) {
        return historyCache.computeIfAbsent(concept.getId(),
                k -> createInitialVersion(concept));
    }

    /**
     * 获取特定版本 (Get specific version)
     *
     * @param conceptId 概念ID (Concept ID)
     * @param versionNumber 版本号 (Version number)
     * @return 概念版本 (Concept version)
     */
    public ConceptVersion getVersion(String conceptId, int versionNumber) {
        ConceptHistory history = getHistory(conceptId);
        if (history == null) {
            return null;
        }
        return history.getVersion(versionNumber);
    }

    /**
     * 获取最新版本 (Get latest version)
     *
     * @param conceptId 概念ID (Concept ID)
     * @return 概念版本 (Concept version)
     */
    public ConceptVersion getLatestVersion(String conceptId) {
        ConceptHistory history = getHistory(conceptId);
        if (history == null) {
            return null;
        }
        return history.getLatestVersion();
    }

    /**
     * 获取最近的版本列表 (Get recent versions)
     *
     * @param conceptId 概念ID (Concept ID)
     * @param count 数量 (Count)
     * @return 版本列表 (Version list)
     */
    public List<ConceptVersion> getRecentVersions(String conceptId, int count) {
        ConceptHistory history = getHistory(conceptId);
        if (history == null) {
            return new ArrayList<>();
        }
        return history.getRecentVersions(count);
    }

    /**
     * 获取版本数量 (Get version count)
     *
     * @param conceptId 概念ID (Concept ID)
     * @return 版本数量 (Version count)
     */
    public int getVersionCount(String conceptId) {
        ConceptHistory history = getHistory(conceptId);
        return history != null ? history.getVersionCount() : 0;
    }

    // ==================== 版本比较 (Version Comparison) ====================

    /**
     * 比较两个版本 (Compare two versions)
     *
     * @param conceptId 概念ID (Concept ID)
     * @param version1 版本1 (Version 1)
     * @param version2 版本2 (Version 2)
     * @return 差异描述 (Difference description)
     */
    public String compareVersions(String conceptId, int version1, int version2) {
        ConceptHistory history = getHistory(conceptId);
        if (history == null) {
            return "概念历史不存在 (Concept history not found)";
        }
        return history.compareVersions(version1, version2);
    }

    /**
     * 回滚到指定版本 (Rollback to specific version)
     *
     * @param conceptId 概念ID (Concept ID)
     * @param targetVersion 目标版本号 (Target version number)
     * @param operator 操作者 (Operator)
     * @return 回滚后的概念 (Rolled back concept)
     */
    public ConceptUnit rollbackToVersion(String conceptId, int targetVersion, String operator) {
        log.info(I18N.get("concept.version.rollback.old", conceptId, targetVersion));

        ConceptHistory history = getHistory(conceptId);
        if (history == null) {
            log.error(I18N.get("concept.version.history.notfound", conceptId));
            return null;
        }

        ConceptVersion targetVersionObj = history.getVersion(targetVersion);
        if (targetVersionObj == null) {
            log.error(I18N.get("concept.version.notfound", conceptId, targetVersion));
            return null;
        }

        ConceptUnit rolledBackConcept = cloneConcept(targetVersionObj.getSnapshot());

        // 创建回滚记录 (Create rollback record)
        createNewVersion(
                rolledBackConcept,
                ConceptVersion.ChangeType.UPDATE,
                "回滚到版本 " + targetVersion + " (Rollback to version " + targetVersion + ")",
                "手动回滚 (Manual rollback)",
                operator
        );

        log.info(I18N.get("concept.version.rollback.success", conceptId, targetVersion));
        return rolledBackConcept;
    }

    // ==================== 版本清理 (Version Cleanup) ====================

    /**
     * 清理旧版本 (Cleanup old versions)
     * 保留最近的版本和重要版本 (Keep recent and important versions)
     *
     * @param conceptId 概念ID (Concept ID)
     */
    public void cleanupOldVersions(String conceptId) {
        log.info(I18N.get("concept.version.cleanup.start", conceptId));

        ConceptHistory history = getHistory(conceptId);
        if (history == null) {
            return;
        }

        List<ConceptVersion> versions = history.getVersions();
        int versionCount = versions.size();

        if (versionCount <= maxVersionsPerConcept) {
            log.debug(I18N.get("concept.version.cleanup.skip", conceptId, versionCount));
            return;
        }

        // 清理策略 (Cleanup strategy):
        // 1. 保留创建版本 (Keep creation version)
        // 2. 保留标记为 stable 的版本 (Keep stable versions)
        // 3. 保留最近的版本 (Keep recent versions)

        List<ConceptVersion> toKeep = new ArrayList<>();

        // 保留创建版本 (Keep creation version)
        ConceptVersion creationVersion = history.getCreationVersion();
        if (creationVersion != null) {
            toKeep.add(creationVersion);
        }

        // 保留稳定版本 (Keep stable versions)
        versions.stream()
                .filter(ConceptVersion::isStable)
                .forEach(toKeep::add);

        // 保留最近的版本 (Keep recent versions)
        int recentCount = maxVersionsPerConcept / 2;
        List<ConceptVersion> recentVersions = history.getRecentVersions(recentCount);
        toKeep.addAll(recentVersions);

        // 去重 (Remove duplicates)
        Set<String> keptVersionIds = new HashSet<>();
        List<ConceptVersion> finalVersions = new ArrayList<>();

        for (ConceptVersion version : toKeep) {
            if (keptVersionIds.add(version.getVersionId())) {
                finalVersions.add(version);
            }
        }

        // 按版本号排序 (Sort by version number)
        finalVersions.sort(Comparator.comparingInt(ConceptVersion::getVersionNumber));

        int removedCount = versionCount - finalVersions.size();
        history.setVersions(finalVersions);

        log.info(I18N.get("concept.version.cleanup.complete", conceptId, removedCount, finalVersions.size()));
    }

    // ==================== 统计信息 (Statistics) ====================

    /**
     * 获取统计信息 (Get statistics)
     *
     * @return 统计信息 (Statistics)
     */
    public Map<String, Object> getStatistics() {
        Map<String, Object> stats = new HashMap<>();

        int totalConcepts = historyCache.size();
        int totalVersions = historyCache.values().stream()
                .mapToInt(ConceptHistory::getVersionCount)
                .sum();

        double avgVersionsPerConcept = totalConcepts > 0
                ? (double) totalVersions / totalConcepts
                : 0.0;

        stats.put("totalConcepts", totalConcepts);
        stats.put("totalVersions", totalVersions);
        stats.put("avgVersionsPerConcept", avgVersionsPerConcept);
        stats.put("maxVersionsPerConcept", maxVersionsPerConcept);

        return stats;
    }

    // ==================== 辅助方法 (Helper Methods) ====================

    /**
     * 生成版本ID (Generate version ID)
     */
    private String generateVersionId(String conceptId, int versionNumber) {
        return String.format("%s_v%d_%d", conceptId, versionNumber, System.currentTimeMillis());
    }

    /**
     * 生成历史ID (Generate history ID)
     */
    private String generateHistoryId(String conceptId) {
        return String.format("history_%s_%d", conceptId, System.currentTimeMillis());
    }

    /**
     * 克隆概念 (Clone concept)
     * 创建概念的深拷贝 (Create deep copy of concept)
     */
    private ConceptUnit cloneConcept(ConceptUnit original) {
        return ConceptUnit.builder()
                .id(original.getId())
                .name(original.getName())
                .type(original.getType())
                .level(original.getLevel())
                .roleId(original.getRoleId())
                .definition(original.getDefinition())
                .description(original.getDescription())
                .keywords(new ArrayList<>(original.getKeywords()))
                .examples(new ArrayList<>(original.getExamples()))
                .parentId(original.getParentId())
                .childIds(new ArrayList<>(original.getChildIds()))
                .relatedIds(new ArrayList<>(original.getRelatedIds()))
                .embedding(original.getEmbedding() != null ? original.getEmbedding().clone() : null)
                .embeddingDimension(original.getEmbeddingDimension())
                .version(original.getVersion())
                .hasHistory(original.isHasHistory())
                .createdAt(original.getCreatedAt())
                .updatedAt(original.getUpdatedAt())
                .createdBy(original.getCreatedBy())
                .updatedBy(original.getUpdatedBy())
                .importance(original.getImportance())
                .healthScore(original.getHealthScore())
                .disputeCount(original.getDisputeCount())
                .accessCount(original.getAccessCount())
                .lastAccessedAt(original.getLastAccessedAt())
                .enabled(original.isEnabled())
                .needsReview(original.isNeedsReview())
                .inVoting(original.isInVoting())
                .currentVotingSessionId(original.getCurrentVotingSessionId())
                .metadata(new HashMap<>(original.getMetadata()))
                .sourceDocumentId(original.getSourceDocumentId())
                .sourceDocumentPath(original.getSourceDocumentPath())
                .build();
    }
}

