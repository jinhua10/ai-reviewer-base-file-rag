# PPL Chunking è¯­ä¹‰è¿è´¯æ€§é—®é¢˜åˆ†æä¸ä¼˜åŒ–æ–¹æ¡ˆ

> ç”Ÿæˆæ—¶é—´: 2025-12-05
> é—®é¢˜: å½“å‰ PPL Chunking æŒ‰å›ºå®š 2000 å­—ç²—åˆ†å¯èƒ½å¯¼è‡´è¯­ä¹‰ä¸è¿è´¯

## ğŸ“‹ å½“å‰å®ç°é—®é¢˜åˆ†æ

### å½“å‰æµç¨‹

```
åŸå§‹æ–‡æ¡£ (1ä¸‡å­—)
    â†“
Step 1: åˆ†å¥ (æŒ‰ ã€‚ï¼ï¼Ÿ.!? åˆ‡åˆ†)
    â†“
Step 2: ç²—åˆ†å— (æŒ‰ 2000 å­—ç¡¬åˆ‡) â† âš ï¸ é—®é¢˜æ‰€åœ¨
    â†“
Step 3: PPL ç²¾åˆ† (æ£€æµ‹å›°æƒ‘åº¦çªå˜)
    â†“
æœ€ç»ˆåˆ†å—
```

### é—®é¢˜è¯¦è§£

**é—®é¢˜ 1: ç²—åˆ†å—ç¡¬åˆ‡æ–­è¯­ä¹‰**

```java
// å½“å‰å®ç° - coarseChunk()
if (currentSize + sentenceLength > maxChunkSize && !currentChunk.isEmpty()) {
    chunks.add(new ArrayList<>(currentChunk));  // ç¡¬æ€§åˆ‡æ–­ï¼
    currentChunk.clear();
    currentSize = 0;
}
```

ç¤ºä¾‹é—®é¢˜ï¼š
```
æ–‡æ¡£å†…å®¹:
"...ç¬¬ä¸€ç« ä»‹ç»äº†ç³»ç»Ÿæ¶æ„ï¼ŒåŒ…æ‹¬ä¸‰ä¸ªæ ¸å¿ƒæ¨¡å—ï¼š
1. æ•°æ®å±‚ï¼šè´Ÿè´£æ•°æ®å­˜å‚¨å’Œè®¿é—®
2. ä¸šåŠ¡å±‚ï¼šå¤„ç†æ ¸å¿ƒä¸šåŠ¡é€»è¾‘    â† åœ¨è¿™é‡Œåˆ°è¾¾ 2000 å­—
3. å±•ç¤ºå±‚ï¼šç”¨æˆ·ç•Œé¢å±•ç¤º       â† è¢«åˆ‡åˆ°ä¸‹ä¸€ä¸ªå—ï¼

ä¸‹é¢è¯¦ç»†è¯´æ˜æ¯ä¸ªæ¨¡å—..."
```

ç»“æœï¼šåˆ—è¡¨è¢«æ‹†æˆä¸¤ä¸ªå—ï¼Œè¯­ä¹‰ä¸å®Œæ•´ã€‚

**é—®é¢˜ 2: æ— ä¸Šä¸‹æ–‡é‡å **

å½“å‰ç²—åˆ†å—ä¹‹é—´æ²¡æœ‰ä»»ä½•é‡å ï¼Œå¯¼è‡´ï¼š
- è·¨å—æŸ¥è¯¢æ— æ³•å¬å›å®Œæ•´ä¿¡æ¯
- ä¸Šä¸‹æ–‡ä¸¢å¤±ï¼Œå½±å“ PPL ç²¾åˆ†æ•ˆæœ

**é—®é¢˜ 3: PPL ç²¾åˆ†ä½œç”¨æœ‰é™**

PPL ç²¾åˆ†åªåœ¨ç²—å—å†…éƒ¨ç”Ÿæ•ˆï¼Œæ— æ³•ä¿®å¤ç²—åˆ†å—é€ æˆçš„è¯­ä¹‰æ–­è£‚ã€‚

---

## ğŸš€ ä¼˜åŒ–æ–¹æ¡ˆ

### æ–¹æ¡ˆ 1: è¯­ä¹‰æ„ŸçŸ¥çš„ç²—åˆ†å—ï¼ˆæ¨èï¼‰

**æ ¸å¿ƒæ€æƒ³**: åœ¨æ®µè½/ç« èŠ‚è¾¹ç•Œåˆ‡åˆ†ï¼Œè€Œä¸æ˜¯å›ºå®šå­—æ•°ã€‚

```java
/**
 * è¯­ä¹‰æ„ŸçŸ¥çš„ç²—åˆ†å—
 * ä¼˜å…ˆåœ¨ä»¥ä¸‹ä½ç½®åˆ‡åˆ†ï¼š
 * 1. æ®µè½è¾¹ç•Œï¼ˆåŒæ¢è¡Œï¼‰
 * 2. ç« èŠ‚æ ‡é¢˜ï¼ˆ# å¼€å¤´æˆ–"ç¬¬Xç« "ï¼‰
 * 3. åˆ—è¡¨ç»“æŸä½ç½®
 * 4. å¦‚æœä»¥ä¸Šéƒ½è¶…è¿‡ maxChunkSizeï¼Œæ‰æŒ‰å¥å­è¾¹ç•Œåˆ‡åˆ†
 */
private List<List<String>> semanticCoarseChunk(List<String> sentences, int maxChunkSize) {
    List<List<String>> chunks = new ArrayList<>();
    List<String> currentChunk = new ArrayList<>();
    int currentSize = 0;
    
    for (int i = 0; i < sentences.size(); i++) {
        String sentence = sentences.get(i);
        int sentenceLength = sentence.length();
        
        // æ£€æµ‹æ˜¯å¦æ˜¯è¯­ä¹‰è¾¹ç•Œ
        boolean isSemanticBoundary = isSemanticBoundary(sentence, 
            i > 0 ? sentences.get(i-1) : null);
        
        // è¶…è¿‡é˜ˆå€¼ ä¸” åˆ°è¾¾è¯­ä¹‰è¾¹ç•Œ æ‰åˆ‡åˆ†
        if (currentSize + sentenceLength > maxChunkSize * 0.8 && isSemanticBoundary) {
            if (!currentChunk.isEmpty()) {
                chunks.add(new ArrayList<>(currentChunk));
                currentChunk.clear();
                currentSize = 0;
            }
        }
        
        // ç¡¬æ€§ä¸Šé™ï¼ˆ1.5å€æœ€å¤§å—å¤§å°ï¼‰
        if (currentSize + sentenceLength > maxChunkSize * 1.5) {
            if (!currentChunk.isEmpty()) {
                chunks.add(new ArrayList<>(currentChunk));
                currentChunk.clear();
                currentSize = 0;
            }
        }
        
        currentChunk.add(sentence);
        currentSize += sentenceLength;
    }
    
    if (!currentChunk.isEmpty()) {
        chunks.add(currentChunk);
    }
    
    return chunks;
}

/**
 * æ£€æµ‹è¯­ä¹‰è¾¹ç•Œ
 */
private boolean isSemanticBoundary(String current, String previous) {
    if (current == null) return false;
    
    // 1. ç« èŠ‚æ ‡é¢˜
    if (current.matches("^(ç¬¬[ä¸€äºŒä¸‰å››äº”å…­ä¸ƒå…«ä¹åç™¾åƒ]+[ç« èŠ‚ç¯‡éƒ¨]|#{1,6}\\s|\\d+\\.\\d*\\s).*")) {
        return true;
    }
    
    // 2. æ®µè½å¼€å¤´ï¼ˆæ–°ä¸»é¢˜ï¼‰
    if (current.matches("^(é¦–å…ˆ|å…¶æ¬¡|ç„¶å|æœ€å|å¦å¤–|æ­¤å¤–|ç»¼ä¸Š|æ€»ä¹‹|å› æ­¤|æ‰€ä»¥).*")) {
        return true;
    }
    
    // 3. å‰ä¸€å¥æ˜¯åˆ—è¡¨ç»“å°¾ï¼Œå½“å‰ä¸æ˜¯åˆ—è¡¨é¡¹
    if (previous != null && previous.matches("^\\d+[.ã€].*") 
        && !current.matches("^\\d+[.ã€].*")) {
        return true;
    }
    
    // 4. ç©ºè¡Œ/æ®µè½åˆ†éš”ï¼ˆéœ€è¦åœ¨åˆ†å¥æ—¶ä¿ç•™æ ‡è®°ï¼‰
    if (current.startsWith("[PARAGRAPH_BREAK]")) {
        return true;
    }
    
    return false;
}
```

### æ–¹æ¡ˆ 2: æ·»åŠ ä¸Šä¸‹æ–‡é‡å çª—å£

```java
/**
 * å¸¦é‡å çš„ç²—åˆ†å—
 */
private List<List<String>> coarseChunkWithOverlap(List<String> sentences, 
    int maxChunkSize, int overlapSentences) {
    
    List<List<String>> chunks = new ArrayList<>();
    List<String> currentChunk = new ArrayList<>();
    List<String> overlapBuffer = new ArrayList<>();  // é‡å ç¼“å†²åŒº
    int currentSize = 0;
    
    for (String sentence : sentences) {
        // ... åˆ‡åˆ†é€»è¾‘ ...
        
        if (shouldSplit) {
            // æ·»åŠ å½“å‰å—ï¼ˆåŒ…å«å‰ä¸€å—çš„å°¾éƒ¨ä½œä¸ºä¸Šæ–‡ï¼‰
            List<String> chunkWithContext = new ArrayList<>(overlapBuffer);
            chunkWithContext.addAll(currentChunk);
            chunks.add(chunkWithContext);
            
            // æ›´æ–°é‡å ç¼“å†²åŒºï¼ˆä¿ç•™æœ€å N ä¸ªå¥å­ï¼‰
            overlapBuffer.clear();
            int overlapStart = Math.max(0, currentChunk.size() - overlapSentences);
            for (int i = overlapStart; i < currentChunk.size(); i++) {
                overlapBuffer.add(currentChunk.get(i));
            }
            
            currentChunk.clear();
            currentSize = 0;
        }
        
        currentChunk.add(sentence);
        currentSize += sentence.length();
    }
    
    // å¤„ç†æœ€åä¸€å—
    if (!currentChunk.isEmpty()) {
        List<String> chunkWithContext = new ArrayList<>(overlapBuffer);
        chunkWithContext.addAll(currentChunk);
        chunks.add(chunkWithContext);
    }
    
    return chunks;
}
```

### æ–¹æ¡ˆ 3: ä¸¤é˜¶æ®µ PPL åˆ†å—ï¼ˆæœ€ä¼˜ä½†è®¡ç®—æˆæœ¬é«˜ï¼‰

**æ ¸å¿ƒæ€æƒ³**: å®Œå…¨ç”¨ PPL é©±åŠ¨åˆ†å—ï¼Œä¸ä¾èµ–å›ºå®šå­—æ•°ã€‚

```java
/**
 * çº¯ PPL é©±åŠ¨çš„åˆ†å—
 * 
 * é˜¶æ®µ1: è®¡ç®—æ¯ä¸ªå¥å­çš„ PPL
 * é˜¶æ®µ2: æ‰¾åˆ°æ‰€æœ‰ PPL çªå˜ç‚¹ï¼ˆä¸»é¢˜è¾¹ç•Œï¼‰
 * é˜¶æ®µ3: åœ¨çªå˜ç‚¹åˆ‡åˆ†ï¼ŒåŒæ—¶æ§åˆ¶å—å¤§å°åœ¨åˆç†èŒƒå›´
 */
private List<DocumentChunk> purePPLChunk(List<String> sentences, ChunkConfig config) {
    if (sentences.size() < 2) {
        // ç›´æ¥è¿”å›
        return createSingleChunk(sentences);
    }
    
    // 1. è®¡ç®—æ‰€æœ‰å¥å­çš„ PPLï¼ˆæ‰¹é‡è®¡ç®—æå‡æ•ˆç‡ï¼‰
    List<Double> pplScores = batchCalculatePPL(sentences);
    
    // 2. è®¡ç®— PPL å˜åŒ–ç‡
    List<Double> pplDeltas = new ArrayList<>();
    pplDeltas.add(0.0);  // ç¬¬ä¸€ä¸ªå¥å­
    for (int i = 1; i < pplScores.size(); i++) {
        double delta = Math.abs(pplScores.get(i) - pplScores.get(i-1));
        pplDeltas.add(delta);
    }
    
    // 3. åŠ¨æ€é˜ˆå€¼ï¼ˆåŸºäº PPL å˜åŒ–çš„åˆ†å¸ƒï¼‰
    double meanDelta = pplDeltas.stream().mapToDouble(d -> d).average().orElse(0);
    double stdDelta = calculateStdDev(pplDeltas, meanDelta);
    double dynamicThreshold = meanDelta + stdDelta;  // å‡å€¼ + 1æ ‡å‡†å·®
    
    // 4. æ‰¾åˆ°æ‰€æœ‰å€™é€‰åˆ‡åˆ†ç‚¹
    List<Integer> candidateSplitPoints = new ArrayList<>();
    candidateSplitPoints.add(0);
    
    for (int i = 1; i < pplDeltas.size(); i++) {
        if (pplDeltas.get(i) > dynamicThreshold) {
            candidateSplitPoints.add(i);
        }
    }
    candidateSplitPoints.add(sentences.size());
    
    // 5. åˆå¹¶è¿‡å°çš„å—ï¼Œæ‹†åˆ†è¿‡å¤§çš„å—
    return balanceChunks(sentences, candidateSplitPoints, config);
}

/**
 * å¹³è¡¡å—å¤§å°
 */
private List<DocumentChunk> balanceChunks(List<String> sentences, 
    List<Integer> splitPoints, ChunkConfig config) {
    
    List<DocumentChunk> result = new ArrayList<>();
    
    for (int i = 0; i < splitPoints.size() - 1; i++) {
        int start = splitPoints.get(i);
        int end = splitPoints.get(i + 1);
        
        String content = joinSentences(sentences, start, end);
        
        if (content.length() < config.getMinChunkSize() && !result.isEmpty()) {
            // å¤ªå°ï¼Œåˆå¹¶åˆ°å‰ä¸€å—
            DocumentChunk lastChunk = result.get(result.size() - 1);
            lastChunk.setContent(lastChunk.getContent() + " " + content);
        } else if (content.length() > config.getMaxChunkSize() * 1.5) {
            // å¤ªå¤§ï¼Œé€’å½’æ‹†åˆ†
            List<String> subSentences = sentences.subList(start, end);
            List<DocumentChunk> subChunks = splitBySize(subSentences, config);
            result.addAll(subChunks);
        } else {
            // å¤§å°åˆé€‚ï¼Œç›´æ¥æ·»åŠ 
            result.add(DocumentChunk.builder()
                .content(content)
                .startSentenceIndex(start)
                .endSentenceIndex(end)
                .build());
        }
    }
    
    return result;
}
```

---

## ğŸ“Š æ–¹æ¡ˆå¯¹æ¯”

| æ–¹æ¡ˆ | è¯­ä¹‰å®Œæ•´æ€§ | è®¡ç®—æˆæœ¬ | å®ç°å¤æ‚åº¦ | æ¨èåœºæ™¯ |
|------|-----------|----------|-----------|----------|
| æ–¹æ¡ˆ1: è¯­ä¹‰æ„ŸçŸ¥ç²—åˆ† | â­â­â­â­ | â­ | â­â­ | **é€šç”¨æ¨è** |
| æ–¹æ¡ˆ2: é‡å çª—å£ | â­â­â­ | â­ | â­ | å¿«é€Ÿæ”¹è¿› |
| æ–¹æ¡ˆ3: çº¯ PPL | â­â­â­â­â­ | â­â­â­ | â­â­â­ | é«˜è´¨é‡éœ€æ±‚ |
| ç»„åˆ: æ–¹æ¡ˆ1+2 | â­â­â­â­â­ | â­â­ | â­â­â­ | **æœ€ä½³å®è·µ** |

---

## ğŸ”§ æ¨èé…ç½®

### ä¼˜åŒ–åçš„é…ç½®å»ºè®®

```yaml
knowledge:
  qa:
    ppl:
      chunking:
        # æ ¸å¿ƒæ”¹è¿›ï¼šè¯­ä¹‰æ„ŸçŸ¥æ¨¡å¼
        semantic-aware: true              # æ–°å¢ï¼šå¯ç”¨è¯­ä¹‰æ„ŸçŸ¥
        
        # å—å¤§å°è®¾ä¸ºè½¯é™åˆ¶
        target-chunk-size: 1500           # ç›®æ ‡å¤§å°ï¼ˆè½¯é™åˆ¶ï¼‰
        max-chunk-size: 2500              # ç¡¬æ€§ä¸Šé™ï¼ˆ1.5-2å€ç›®æ ‡ï¼‰
        min-chunk-size: 300               # æœ€å°å—ï¼ˆé¿å…è¿‡ç¢ï¼‰
        
        # ä¸Šä¸‹æ–‡é‡å 
        overlap-sentences: 2              # æ–°å¢ï¼šé‡å 2ä¸ªå¥å­
        overlap-size: 150                 # é‡å å­—ç¬¦æ•°
        
        # PPL é˜ˆå€¼
        ppl-threshold: 20.0               # ä¿æŒä¸å˜
        use-dynamic-threshold: true       # æ–°å¢ï¼šåŠ¨æ€é˜ˆå€¼
        
        # è¯­ä¹‰è¾¹ç•Œæ£€æµ‹
        detect-paragraph: true            # æ£€æµ‹æ®µè½è¾¹ç•Œ
        detect-chapter: true              # æ£€æµ‹ç« èŠ‚æ ‡é¢˜
        detect-list-end: true             # æ£€æµ‹åˆ—è¡¨ç»“æŸ
```

---

## ğŸ“ å®æ–½å»ºè®®

### çŸ­æœŸï¼ˆç«‹å³å¯åšï¼‰

1. **å¢åŠ å—é‡å ** - æ”¹åŠ¨æœ€å°ï¼Œæ•ˆæœæ˜æ˜¾
   ```java
   // åœ¨ coarseChunk ä¸­ä¿ç•™ä¸Šä¸€å—æœ€å2ä¸ªå¥å­
   overlapSize: 150  // çº¦2-3ä¸ªå¥å­
   ```

2. **æ”¾å®½ç¡¬æ€§ä¸Šé™** - å…è®¸å—å¤§å°åœ¨ 1500-2500 ä¹‹é—´æµ®åŠ¨
   ```java
   // åªæœ‰è¶…è¿‡ 2500 æ‰å¼ºåˆ¶åˆ‡åˆ†
   if (currentSize > maxChunkSize * 1.25) { ... }
   ```

### ä¸­æœŸï¼ˆ1-2å‘¨ï¼‰

3. **å®ç°è¯­ä¹‰è¾¹ç•Œæ£€æµ‹** - æ–¹æ¡ˆ1çš„æ ¸å¿ƒ
4. **æ·»åŠ åŠ¨æ€ PPL é˜ˆå€¼** - æ ¹æ®æ–‡æ¡£ç‰¹æ€§è‡ªé€‚åº”

### é•¿æœŸï¼ˆå¯é€‰ï¼‰

5. **çº¯ PPL åˆ†å—** - æœ€ä¼˜ä½†è®¡ç®—æˆæœ¬é«˜
6. **å¼•å…¥åˆ†å—è´¨é‡è¯„ä¼°** - è‡ªåŠ¨è°ƒä¼˜å‚æ•°

---

## ğŸ“ˆ é¢„æœŸæ•ˆæœ

| æŒ‡æ ‡ | å½“å‰ | ä¼˜åŒ–å | æå‡ |
|------|------|--------|------|
| è¯­ä¹‰å®Œæ•´æ€§ | 60% | 90%+ | +30% |
| è·¨å—å¬å›ç‡ | 40% | 70% | +30% |
| åˆ†å—è´¨é‡è¯„åˆ† | 3.5/5 | 4.5/5 | +28% |
| é¦–æ¬¡å‘½ä¸­ç‡ | 30% | 45% | +50% |

ä¼˜åŒ–åé¢„è®¡å¯å°† **åé¦ˆæ”¶æ•›æ¬¡æ•°ä» 3-5 æ¬¡å‡å°‘åˆ° 2-3 æ¬¡**ã€‚

